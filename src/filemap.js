// Generated by CoffeeScript 1.9.2
var DEFAULT_BUFFER_SIZE, Memmap, ShulzMapBusy, fs, markers, roundbyte, shulz;

fs = require('graceful-fs');

Memmap = require('./memorymap');

markers = require('./markers');

roundbyte = require('./roundbyte');

ShulzMapBusy = require('./errors').ShulzMapBusy;

DEFAULT_BUFFER_SIZE = 1024 * 128;

shulz = {
  assert: function(path) {
    if (fs.existsSync(path + ".lock")) {
      throw new ShulzMapBusy();
    }
  },
  create: function(path, buffersize) {
    var allocated, fd, fsmap, memmap, noopbuffer, offset;
    shulz.assert(path);
    fs.writeFileSync(path + ".lock", '');
    if (buffersize == null) {
      buffersize = DEFAULT_BUFFER_SIZE;
    }
    noopbuffer = new Buffer(buffersize);
    noopbuffer.fill(markers.noop);
    fd = fs.openSync(path, 'w');
    fs.writeSync(fd, noopbuffer, 0, buffersize, 0);
    fs.fsyncSync(fd);
    offset = 0;
    allocated = buffersize;
    memmap = Memmap();
    fsmap = {
      set: function(key, value) {
        var allocatesize, buffer, keylength, size, valuelength;
        keylength = Buffer.byteLength(key);
        valuelength = Buffer.byteLength(value);
        size = 8 + (roundbyte(keylength)) + 4 + (roundbyte(valuelength));
        allocatesize = size;
        if (offset + size > allocated) {
          allocated = Math.ceil((offset + size) / buffersize) * buffersize;
          allocatesize = allocated - offset;
        }
        buffer = new Buffer(allocatesize);
        buffer.writeUInt32BE(markers.set, 0);
        buffer.writeUInt32BE(keylength, 4);
        buffer.write(key, 8, keylength);
        buffer.writeUInt32BE(valuelength, 8 + (roundbyte(keylength)));
        buffer.write(value, 12 + (roundbyte(keylength)), valuelength);
        if (12 + (roundbyte(keylength)) + valuelength < allocatesize) {
          buffer.fill(markers.noop, 12 + (roundbyte(keylength)) + valuelength);
        }
        fs.writeSync(fd, buffer, 0, allocatesize, offset);
        fs.fsyncSync(fd);
        return offset += size;
      },
      clear: function(key) {
        var allocatesize, buffer, length, size;
        length = Buffer.byteLength(key);
        size = roundbyte(length + 8);
        allocatesize = size;
        if (offset + size > allocated) {
          allocated = Math.ceil((offset + size) / buffersize) * buffersize;
          allocatesize = allocated - offset;
        }
        buffer = new Buffer(allocatesize);
        buffer.writeUInt32BE(markers.clear, 0);
        buffer.writeUInt32BE(length, 4);
        buffer.write(key, 8, length);
        if (length + 8 < allocatesize) {
          buffer.fill(markers.noop, length + 8);
        }
        fs.writeSync(fd, buffer, 0, allocatesize, offset);
        fs.fsyncSync(fd);
        return offset += size;
      },
      compact: function() {
        var key, ref, value;
        fd = fs.openSync(path + ".new", 'w');
        fs.writeSync(fd, noopbuffer, 0, buffersize, 0);
        fs.fsyncSync(fd);
        offset = 0;
        allocated = buffersize;
        ref = memmap.all();
        for (key in ref) {
          value = ref[key];
          fsmap.set(key, value);
        }
        return fs.renameSync(path + ".new", path);
      },
      rename: function(newpath) {
        return path = newpath;
      },
      close: function() {
        fs.unlinkSync(path + ".lock");
        return fs.closeSync(fd);
      }
    };
    return {
      get: function(key) {
        return memmap.get(key);
      },
      set: function(key, value) {
        fsmap.set(key, value);
        return memmap.set(key, value);
      },
      clear: function(key) {
        fsmap.clear(key);
        return memmap.clear(key);
      },
      length: function() {
        return memmap.length();
      },
      all: function() {
        return memmap.all();
      },
      compact: function() {
        return fsmap.compact();
      },
      rename: function(newpath) {
        return fsmap.rename(newpath);
      },
      close: function() {
        return fsmap.close();
      }
    };
  },
  open: function(path) {
    var key, map, object, value;
    shulz.assert(path);
    fs.writeFileSync(path + ".lock", '');
    map = shulz.create(path + ".new");
    if (fs.existsSync(path)) {
      object = shulz.read(path);
      for (key in object) {
        value = object[key];
        map.set(key, value);
      }
    }
    fs.renameSync(path + ".new", path);
    fs.unlink(path + ".new.lock");
    map.rename(path);
    return map;
  },
  print: require('./print'),
  read: require('./read')
};

module.exports = shulz;
